# 19 Fri

## \[HEAD FIRST PYTHON\] 8강 클래스 맛보기 : 동작과 상태 추상화 <a id="sql"></a>

### WITH

* 파이썬은 유연한 언어로 객체 지향으로 프로그래밍 할 필요는 없다.
  * 오히려 클래스를 이용하여 with문과 연결할 것을 권장한다.
  * 표준 라이브러리는 범용성이 떨어지기 때문에 클래스를 이용하는 방법을 살펴볼 것
* with문과 연결하려면 클래스를 만들어야 한다.
  * 이후 컨텍스트 관리 프로토콜을 준수하는 클래스를 구현할 것.
* 파이썬은 상속, 다형성을 지원하지만 캡슐화를 주로 사용한다.



### 클래스

* 클래스는 한 객체에 동작과 상태를 묶을 수 있다.
  * 동작은 무언가를 수행하는 함수. =&gt; 메서드
  * 상태는 클래스 내부의 변수 =&gt; 속성
* `class <classname>:` 로 선언한다.
* 만들어진 클래스는 호출해서 새로운 클래스 변수로 정의하는 것을 객체 인스턴화라고 한다.
* 함수와 구분할 수 있는 방법은 없다.
  * 보통 함수명은 소문자와 언더스코어로 클래스명은 캐멀케이스로 표기하도록 권장한다.
* 같은 클래스에 대한 인스턴스는 메서드는 공유하지만 속성은 공유하지 않음.
  * 이 뜻은 메서드는 동일한 코드로 작동되지만 속성은 개별 공간으로 유지된다는 뜻.
* 메서드 호출은 `.` 을 사용
  * ex\) `c.increase()`
* 인터프리터는 `c.increase()` 를 `CountFromBy.increase(c)` 로 바꾸어 해석하는데 이는 메서드의 인자인 `self` 와 관련이 있다.
  * 실제로 메서드 선언시 `def increase()` 를 하면 런타임 에러가 발생하며 `def increase(self)` 로 정의해야 한다.
  * `self` 는 다른 언어의 `this` 와 동일한 개념이다.
  * 따라서, `self` 를 호출 객체의 첫번째 인자로 항상 선언해야 하며, 유저가 사용할 떄에는 `self` 인자를 넘겨줄 필요가 없다.
* 메서드 내에서는 속성\(변수\)앞에 `self.` 를 명시해야 한다.
  * 이는 클래스의 특징때문이다. 클래스는 메서드는 공유하지만 속성은 공유하지 않기 때문에, 어떤 인스턴스의 속성인지 알기 위함이다.
  * 만일 `self.var` 를 `var` 라고만 쓴다면, 이 변수는 해당 인스턴스의 지역변수일 뿐이며, 메서드가 종료된 뒤에 소멸된다.
* 속성\(변수\)를 초기화할 때는 `__init__` 이라는 요술 메서드로 할 수 있다.

```python
class CountFromBy:
    def __init__(self, v: int=0, i: int=1) -> None:
        self.val = v
        self.incr = i
    def increase(self) -> None:
        self.val += self.incr
```

* 인스턴스 변수를 출력하면 다음과 같은 값이 출력된다.
  * `__main__.CountFromBy object at 0x1035be278`
  * `0x1035be278` 은 해당 인스턴스가 저장되어 있는 메모리 주소이다. 이는 `id()` 함수로도 동일한 주소를 반환받을 수 있다.
* 인스턴스 변수를 출력했을 때 메모리 주소가 아닌 특정 출력값을 정의할 수 있는데 이것이 `__repr__` 이다.

 

