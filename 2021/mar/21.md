# 21 Sun

## \[HEAD FIRST PYTHON\] 10강 장식자 : 함수 장식하기 <a id="sql"></a>

### 웹의 상태

웹은 상태가 없다. 따라서 사용자 인증 정보를 html 폼 또는 python 코드 변수로 처리하고 기억할 수 없다.

* 웹 서버로 세 개의 요청을 보내면 서버는 이를 세 번의 독립적인 개별 요청으로 간주하고 처리한다.
  * 동일한 IP로 이루어진 요청인데도 불가하고
* HTTP 라는 프로토콜의 동작 방식 때문
  * 웹 서버가 모든 요청을 개별 요청으로 취급하도록 강제했다.
    * 웹 서버가 처리해야 할 작업의 양이 최소화되어야 더 많은 요청을 처리할 수 있도록 확장할 수 있기 때문
* HTTP는 작업의 양을 최소화 하기 위해 `상태` 라고 하는 정보를 유지하지 않도록 최적화 되어 있다.
  * 이를 stateless 라고 표현한다.
  * 빠른 응답과 빠른 잊기가 웹의 특기
* 또한 웹 서버는 파이썬 코드를 실행하는 것이 아닌 웹앱 코드를 실행한다.
  * 웹앱 코드가 항상 웹 서버의 메모리에 있는 것이 아니므로 웹앱 코드 상에 있는 변수를 기억할 수 없다.
* 예를 들어 다음과 같은 코드에서 다음 변수는 문제가 된다.
  * 이 변수는 사용자가 로그인 했는지 안했는지를 알려주는 변수이다.

```python
logged_in = False
```

* 문제1
  * 웹 서버는 웹앱 코드를 언제든 메모리에서 해제할 수 있으므로 전역 변수에 저장된 값이 사라질 수 있다.
  * 실제로 로그인을 해서 `logged_in` 이 True가 되더라도 다시 코드를 임포트 했을 경우 False로 되어버린다.
* 문제2
  * 웹 서버가 유저 마다 `logged_in` 변수를 가지고 있어야 한다. 또한, 각각의 유저 변수는 간섭받지 않아야 한다.
* 해결 책
  * 전역 변수를 이용하지 않고 변수를 저장
  * 각각의 사용자 데이터가 서로 간섭받지 않도록 유지
* 대부분의 웹앱 개발 프레임워크는 두 가지 요구사항을 세션이라는 기술로 해결한다.
  * 세션은 상태가 없는 정보

### 세션

* 웹앱은 여전히 상태가 없는 웹에서 수행되지만 세션을 통해 웹앱이 상태를 기억할 수 있는 능력을 얻는다.
* 플라스크는 웹앱을 실행할 때마다 세션에 저장된 데이터를 사용할 수 있으며, 몇 번을 읽어 들였는지는 상관없다.
* 여기서 중요한 점은 플라스크가 어떻게 세션 기능을 처리하는 지 보다는 세션 기능을 제공한다는 점이다. 이 때 쿠키 생성에 필요한 비밀키 정보를 제공해야 하며, 비밀키를 이용해 쿠키를 암호화하고 외부 사용자로부터 정보를 보호한다.

```python
from flask import Flask, session
app = Flask(__name__)
app.secret_key = 'YouWillNeverGuess'

@app.route('/setuser/<user>')
def setuser(user: str) -> str:
    session['user'] = user
    return 'User value set to: ' + session['user']

@app.route('/getuser')
def getuser() -> str:
    return 'User value is currently set to: ' + session['user']
```

* 1 : session 임포트
* 3 : 플라스크의 쿠기 생성에 필요한 비밀키 값을 제공
  * 유추하기 어려운 값으로생성하는 것이 좋음
* 6~8 : session 딕셔너리에 `user`변수의 값을 user로 저장
* 10~12 : user키에 할당된 값에 접근하여 문자열 일부를 반환

### 장식자

장식자를 구현할 때 알아야 할 사실

* 함수를 구현하는 법
* 함수를 함수의 인자로 전달하는 법
* 함수에서 함수를 반환하는 법
* 다양한 개수와 유형의 함수 인자를 처리하는 법
* 
