# 24 Mon

## 코드 구현

### 라이브러리 선언

```python
import pyupbit
import pandas as pd
import time
```

* 1 : upbit 함수들을 사용하기 위한 pyupbit
* 2 : data를 조작하기 위한 pandas
* 3 : time.sleep\(\)을 위한 time
  * 0.1초 동안 쉬게하여 의도하지 않은 충돌 발생 확률을 줄인다.

### 기본 변수 설정 

```python
access, secret = "???", "???"
upbit = pyupbit.Upbit(access, secret)

pd.set_option('display.max_columns', None) # print all columns
pd.set_option('expand_frame_repr', False) # print df on single line

balance = upbit.get_balance("KRW")

trading_time = 0
ma_score_weight = [1.1, 1.05, 0.95, 0.9]
tickers = pyupbit.get_tickers(fiat="KRW")
```

* 1-2 : upbit API를 인증하여 자신의 access와 secret code를 얻는다.
  * 단순 조회가 아닌 주문작업을 필요로 할 때는 IP주소를 등록해야 한다. 이는 네이버에 `내 IP` 를 검색 후 확인 가능
* 4-5 : dataframe의 column이 모두 출력되도록 그리고 한 줄로 출력되도록 설정한다
* 7 : 현재 내 잔고 정보 획득
* 9 : 거래할 시간
  * 반드시 이 시간 이후에 거래해야 한다.
  * 만약 거래 시간이 12시라면 11시 55분이 아니라 12시 5분에 거래해야 한다.
* 10 : 이동평균 점수 가중치
* 11 : 현재 원화로 업비트에 상장되어있는 코인 이름을 모두 불러온다

### 24시간 화폐 정보 조회 함수

#### 정보 조회

```python
def get_ohlcv(ticker):
    date = None
    dfs = []
    for i in range(3):
        df = pyupbit.get_ohlcv(ticker, interval="minute60", to=date, count=24*7)
        if len(df) == 0: break
        dfs.append(df)

        date = df.index[0]
        time.sleep(0.1)
```

* 4-10 : 화폐의 3주간의 정보를 가져온다.
  * interval이 `minute60` 이고 count가 `24*7` 이므로 한번의 `get_ohlcv` 로 1주일의 정보를 얻는다. 반복문이 3번 돌으므로 3주의 정보 획득
  * 1주씩 얻은 정보를 dfs 리스트에 쌓는다.
  * 이 때 `to=date` 는 이 시점 이전까지의 정보를 가져오라는 의미. `df.index[0]` 가 현재까지 가져온 정보 중 가장 오래된 정보이므로 이 인덱스의 날짜를  `date` 로 선언한다.

#### dataframe 조작 : 거래량, 최고가, 최저가, 시가, 변동률, 노이즈

```python
    df = pd.concat(dfs).sort_index()
    df.index.name = 'datetime'
    df.reset_index(inplace=True)

    df['hour'] = df['datetime'].dt.hour
    prev_pm_cum_volume = df['volume'].iloc[-13:-1].sum()
    prev_pm_return = df['close'].iloc[-2] - df['open'].iloc[-13]
    prev_am_cum_volume = df['volume'].iloc[-25:-13].sum()

    high_price_24 = df['high'].rolling(window=24).max().shift(1)
    low_price_24 = df['low'].rolling(window=24).min().shift(1)
    open_price_24 = df['open'].shift(24)

    prev_range = ((high_price_24 - low_price_24) / open_price_24).iloc[-1]
    df['noise1'] = 1 - (abs(open_price_24 - df['open']) / (high_price_24 - low_price_24))
```

* 1-3 : 데이터의 인덱스가 날짜로 되어있는데 이를 컬럼으로 가져온다.
  * 원하는 시간만을 보기 위해 컬럼을 조작해야 하는데 이 값이 인덱스에 있기 때문에 컬럼으로 이동시킨다.
  * 이후, 인덱스는 단순히 0부터 시작하는 순서
* 5 : 각 날짜의 시간 정보를 따로 `hour` column 으로 추가
  * 현재 `datetime` column 은 `YY-MM-DD HH-mm-ss` 의 형태로 있다.
  * 이후에 원하는 시간만을 보기 위해 `hour` 를 따로 빼둔다.
* 6-8 : 오후 거래량, 오후 수익률, 오전 거래량을 구한다.
  * 이 때 인덱스에 대해 -13 부터 -2 까지의 값을 다룬다.
  * -1의 값은 현재 값인데 이 값은 온전히 채워지지 않은 값이므로 제외한다.
    * 만약 현재가 12시 5분이면 `df['volume'].iloc[-1]` 의 값은 5분간 얻어진 거래량이다. 이 값을 비교할 수는 없다.
    * 

#### dataframe 조작 : 3, 5, 10, 20일 이동평균, 20일 노이즈 평균, 거래 조건

```python
    df = df[(df.hour == trading_time)]
    cur_price = df['open'].iloc[-1]

    ma3 = df['close'].iloc[-4:-1].mean()
    ma5 = df['close'].iloc[-6:-1].mean()
    ma10 = df['close'].iloc[-11:-1].mean()
    ma20 = df['close'].iloc[-21:-1].mean()
    ma_score = sum(int(ma < cur_price) * score for ma, score in zip([ma3, ma5, ma10, ma20], ma_score_weight)) / 4

    noise20 = df['noise1'].iloc[-20:].mean()

    target_price = open_price_24.iloc[-1] + prev_range * noise20
    condition = (ma_score > 0) & (cur_price > target_price) & (prev_pm_return > 0) & (prev_pm_cum_volume > prev_am_cum_volume)

    return pd.DataFrame(data=[[ticker, condition, noise20, ma_score, prev_range, cur_price, target_price]],\
                        columns=['ticker', 'condition', 'noise20', 'ma_score', 'prev_range', 'cur_price', 'target_price'])
```

```python

dfs = []
for ticker in tickers:
    df = get_ohlcv(ticker)
    dfs.append(df)
df = pd.concat(dfs).sort_values(by=['condition', 'noise20', 'ma_score'], ascending=[False, True, False])
df = df[(df.condition == True)]
df.to_excel("result.xlsx")
print(df)
```

