---
description: TIL
---

# 15 Tue

## 프로그래머스 AI 스쿨 1기

#### 3주차 DAY 2

##  오토마타와 컴파일러

### CFG : removing ambiguous grammar

 Context Free Grammar는 구문 분석을 하는데 있어서 효율을 상당히 떨어뜨리는 경우에 효율적인 구문분석이 이루어지도록 주어진 문법을 적당한 문법으로 바꾸는 문법 변환을 필요로 한다. 모호한 문법의 제거 방법은 다음과 같다.

* 불필요한 생성규칙의 제거
* ε-생성규칙의 제거
* 단일 생성규칙의 제거
* 좌인수분해
* 좌재귀 제거

 이를 구현하면 다음과 같다. \(**코드를 보기 전에 언을 하자면**, 구현된 제거는 불필요한 생성규칙의 제거, ε-생성규칙의 제거, 단일 생성규칙의 제거 까지이며 이마저도 완벽하게 구현되지 않았다. 지금까지 찾은 반례로는 S -&gt; ABC, A -&gt; B \| a, B -&gt; C \| b, C -&gt; A \| c 와 같은 순환 코드에 대해서 작동하지 않는다. 그 외에는 잘 작동한다고 생각이 들지만 오류를 발생시키는 반례가 충분히 있을 것이라 예상한다. 좌인수분해와 좌재귀제거는 코드가 너무 지저분해져 능력을 벗어나는 일이라고 생각해 포기했다.\)

```text
#
#   data = 2020.12.15
#   author = sangmandu at Dankook Univ.
#   program = Effective Context Free Grammar in that removing unnecessary(ambiguous) grammar
#   language = python
#

#
#   P = Set of grammar
#   S = StartSymbol
#   Z = S' (alternative S that express ε)
#   [A-Z] = Non terminal
#   [a-z][0-9][._()] = Terminal
#   ε = null
#

def initialization(P):
    dic = {}
    Vn, Vt = set(), set()
    for grammar in P:
        src, dst = grammar.split("->")
        Vn.add(src)
        dst = dst.split("|")
        dic.setdefault(src, [])
        for d in dst:
            dic[src].append(d)
            for letter in d:
                if letter.isupper():
                    Vn.add(letter)
                else:
                    Vt.add(letter)
    printResult(initialization.__name__, [dic, Vn, Vt])
    return dic, Vn, Vt

def refreshVnVt(dic):
    Vn, Vt = set(), set()
    for key, values in dic.items():
        Vn.add(key)
        for value in values:
            for letter in value:
                if not letter.isupper():
                    Vt.add(letter)
    return Vn, Vt


def checkNeed(dic, Vn, flag=1):
    stack = ['S']
    _Vn = set()
    while stack:
        nt = stack.pop(0)
        _Vn.add(nt)
        for symbol in dic[nt]:
            for letter in symbol:
                if letter.isupper() and letter not in _Vn and letter not in stack:
                    stack.append(letter)
    for nt in Vn - _Vn:
        del dic[nt]
    Vn, Vt = refreshVnVt(dic)
    if flag:
        printResult(checkNeed.__name__, [dic, Vn, Vt])
    return Vn, Vt

def checkNull(dic, Vn, Vt):
    if 'ε' not in Vt: return Vn, Vt
    _Nt = []
    for nt in Vn:
        if 'ε' in dic[nt]:
            _Nt.append(nt)

    size = 0
    while len(_Nt) != size:
        size = len(_Nt)
        for nt in _Nt:
            for key, value in dic.items():
                for v in value:
                    if nt in v and key not in _Nt:
                        _Nt.append(key)
    for key in Vn:
        stack = dic[key][:]
        dup = []
        while stack:
            value = stack.pop(0)
            if value == "ε":
                continue
            if not value.isupper():
                dic[key].append(value)

            for idx, letter in enumerate(value):
                if letter in _Nt and (value, idx) not in dup:
                    stack.append(value)
                    dup.append((value, idx))
                    stack.append(value[:idx]+value[idx+1:])
            else:
                if value and value not in dic[key]:
                    dic[key].append(value)

    for key, value in dic.items():
        dic[key] = list(set(value))
        while "ε" in dic[key]:
            dic[key].remove("ε")
        while "" in dic[key]:
            dic[key].remove("")

    dic["Z"], dic["S"] = dic["S"], ["Z", "ε"]
    Vn, Vt = refreshVnVt(dic)
    printResult(checkNull.__name__, [dic, Vn, Vt])
    return Vn, Vt

def checkNtoN(dic):
    from itertools import product
    temp = 0
    while True:
        length = sum([len(dic[x]) for x in dic.keys()])
        if temp == length: break
        temp = length
        replace = []
        for key, values in dic.items():
            for value in values:
                if all([letter.isupper() for letter in value]):
                    replace.append((key, value))

        for key, value in replace:
            dic[key].remove(value)
            addvalue = []
            for letter in value:
                addvalue.append(dic[letter])
            for item in list(product(*addvalue)):
                dic[key].append(''.join(item))
    Vn, Vt = refreshVnVt(dic)
    Vn, Vt = checkNeed(dic, Vn, 0)
    printResult(checkNtoN.__name__, [dic, Vn, Vt])
    return Vn, Vt


def checkLeftRecur(dic, Vn):
    Vn, Vt = refreshVnVt(dic)
    printResult(checkLeftRecur.__name__, [dic, Vn, Vt])
    return Vn, Vt


def checkLeftFactor(dic, Vn):
    Vn, Vt = refreshVnVt(dic)
    printResult(checkLeftFactor.__name__, [dic, Vn, Vt])
    return Vn, Vt

def printResult(funcName, arr):
    print()
    print(f"func {funcName}")
    p = ["dic", "Vn", "Vt"]
    for idx, val in enumerate(arr):
        print(f"{p[idx]} = {val}")

P1 = {"S->aB", "A->aB|aC", "B->C|Ee|Bb", "C->b", "D->c", "E->fEgE|gEfE|ε"}
P2 = {"S->ABCD", "A->B|a", "B->C|b", "C->c|ε", "D->Dd"}
P3 = {"S->A|B", "A->C", "C->c", "B->ED|b", "E->e|f", "D->d"}

for P in [P1, P2, P3]:
    print("---------------")
    print(P)
    dic, Vn, Vt = initialization(P)
    Vn, Vt = checkNeed(dic, Vn)
    Vn, Vt = checkNull(dic, Vn, Vt)
    Vn, Vt = checkNtoN(dic)
    Vn, Vt = checkLeftFactor(dic, Vn)
    Vn, Vt = checkLeftRecur(dic, Vn)
    print("---------------")

```

 

