---
description: TIL
---

# 24 Thu

##  \[프로그래머스 AI 스쿨 1기\] 4주차 DAY 1

### Flask App Routing

{% embed url="https://www.javatpoint.com/flask-app-routing" %}

 **앱 라우팅**은 특정 URL을 관련된 함수와 매핑하기 위해 사용한다. 예를 들면,  다음과 같은 URL을 통해 특정 함수를 실행하게 한다.

```python
from flask import Flask  
app = Flask(__name__)  
 
@app.route('/home/<name>')  
def home(name):  
    return "hello,"+name;  
  
if __name__ =="__main__":  
    app.run(debug = True)  
```

URL : /home/&lt;name&gt;

Function : print "hello,"+name;

 이 때, @app.route에서 @를 **decorator**라고 하며, flask에서는 이 장식자가 URL 연결에 활용된다. 장식자를 사용한 다음 행의 함수부터 장식자가 적용된다. 위 코드에서는 home 함수가 바로 적용되는 모습.

![](../../.gitbook/assets/image%20%2875%29.png)

 cmd를 통해 가상환경에서 flask를 실행하면 다음과 같이 출력된다. 이 때 서버와의 통신 메시지를 확인할 수 있으며 **200**은 정상실행, **404**는 존재 하지 않는 URL 에러를 의미한다. **127.0.0.1**은 Localhost 주소라 알려진 인터넷의 루프백 주소이며 **포트번호 5000은** 웹 서버가 실행 중인 프로토콜 포트 번호이다. 포트번호 80은 제품 서버에 사용하고 포트번호 8080이 개발 시 자주 사용하는 포트 중 하나이다. 플라스크는 테스트 프로토콜로 5000번을 사용한다.

### DAY 1 실습

flask에서 **CRUD** 구현하기 

```python
from flask import Flask, jsonify, request
from queue import PriorityQueue

app = Flask(__name__)

menus = [
    {"id":1, "name":"Espresso", "price":3800},
    {"id":2, "name":"Americano", "price":4100},
    {"id":3, "name":"CafeLatte", "price":4600},
]

id_list = PriorityQueue()
for available_id in range(4, 10000): id_list.put(available_id)

# @ = python decorator
# => 다음 주소를 입력받았을 때 아래 함수를 실행하라는 뜻
@app.route('/')
def hello_flask():
    return "Hello World!"

# GET /menus | 자료를 가지고 온다.
@app.route('/menus') # GET은 methods 생략 가능
def get_menus():
    return jsonify({"menus" : menus})

# POST /menus | 자료를 자원에 추가한다.
@app.route('/menus', methods=['POST'])
def create_menu():
    # 전달 받은 자료를 menus 자원에 추가
    # request가 JSON이라고 가정
    request_data = request.get_json() # {"name" : ..., "price" : ...}
    using_id = id_list.get()
    new_menu = {
        "id" : using_id,
        "name" : request_data['name'],
        "price" : request_data['price'],
    }
    menus.append(new_menu)
    return jsonify(new_menu)

@app.route('/menus/<int:id>', methods=['PUT'])
def update_menu(id):
    for idx, menu in enumerate(menus):
        if id in menu.values():
            request_data = request.get_json()
            menus[id-1]["name"] = request_data['name']
            menus[id-1]["price"] = request_data['price']
        return jsonify(menus[id-1])
    return "not existed id"

@app.route('/menus/<int:id>', methods=['DELETE'])
def delete_menu(id):
    for idx, menu in enumerate(menus):
        if id in menu.values():
            id_list.put(menus[idx]["id"])
            menus.pop(idx)
            return "delete successfully"
    return "not existed id"

if __name__ == '__main__':
    app.run()
```

##  \[프로그래머스 AI 스쿨 1기\] 4주차 DAY 2

###  AWS를 활용한 인공지능 모델 배포

 1. 클라우드 기초

 Before Cloud computing

 데이터 센터를 처음 구축할 때 서비스 아키텍처나 자원 예상 사용량 등을 고려해 구

 IDC 등장

 IDC는 Internet Data Center. 서버 운영에 필요한 공간과 네트워크, 유지 보수 등의 서비스를 제공한다. 일정 기간 임대를 하는 유연성이 떨어지는 구조

 Backgrounds of Cloud computing

 인터넷 사용자가 크게 늘고 다양한 서비스를 제공하면 필요한 때에 필요한 만큼만 서버를 원하는 온디맨드 수요 증가. =&gt; 효율성 극대화

 ex\) 사용하지 않는 유휴자원은 빼고, 접속량이 늘거나 컴퓨팅 수요가 증가할 때는 오토 스케일링 사용.

 Cloud Computing

 클라우드라고도 부르며, 인터넷 기반 컴퓨팅의 일종. 2006년 아마존이 S3와 EC2를 개시하면서 본격적인 클라우드 컴퓨팅 시대 시작. IT자원을 인터넷을 통해 제공하고 사용한 만큼만 비용을 지불하는 것이 이전과는 다른 특징

 Features of Cloud Computing

*  속도 - 주문형 셀프 서비스 : 별도의 커뮤니케이션 없이 서비스 바로 이용 가능
*  접근성 : 어떤 디바이스로도 시간과 장소의 제약없이 접근 가능
*  확장성 : 갑작스러운 이용량 증가나 변화에 신속하고 유연하게 확장 가능
*  생산성 : 하드웨어, 소프트웨어 설치에 들어가는 시간과 비용 절감
*  보안, 안정성 : 클라우드 공급자가 전체적으로 보안과 안정성 준비
*  측정 가능성 : 서비스를 사용한 만큼만 계량하여 과금

 클라우드 컴퓨팅 운용 모델

 하이브리드, 프라이빗, 퍼블릭의 세가지 형태로 구분된다.

*  퍼블릭 : 서비스 유지를 위한 모든 인프라와 IT 기술을 클라우드에서 사용. IT관리 인력이나 인프라 구축 비용이 없는 경우 유용
*  프라이빗 : 고객이 자체 데이터센터에서 직접 클라우드 서비스를 구축하는 형태. 보안이 좋고 커스터마이징도 가능하지만 폐쇠적인 환경이라는 점에서 개발측면에서 어려움이 있음
*  하이브리드 : 고객의 핵심 시스템은 내부에 두면서 외부의 클라우드를 활용하는 형태. 퍼블릭의 경제성과 프라이빗의 보안성을 모두 고





